SCALA
=====

Content

- [Objects](#Objects)
- [Classes](#Classes)
- [Traits](#Traits)

## Objects

Objects are single instances of their own definitions. You can think of them as singletons of their own classes.

## Classes

Classes in Scala are blueprints for creating objects. They can contain methods, values, variables, types, objects, traits, and classes which are collectively called members. Types, objects, and traits will be covered later in the tour.



## Traits

Traits are used to share interfaces and fields between classes. They are similar to Java 8¡¯s interfaces. Classes and objects can extend traits but traits cannot be instantiated and therefore have no parameters.


## Higher-order Functions

Scala allows the definition of higher-order functions. These are functions that take other functions as parameters, or whose result is a function. Here is a function ``apply`` which takes another function f and a value ``v`` and applies function ``f`` to ``v``:

## Nested Methods

In Scala it is possible to nest function definitions. The following object provides a factorial function for computing the factorial of a given number:

## Currying

Methods may define multiple parameter lists. When a method is called with a fewer number of parameter lists, then this will yield a function taking the missing parameter lists as its arguments.

## Case Classes

Case classes are like regular classes with a few key differences which we will go over. Case classes are good for modeling immutable data. In the next step of the tour, we¡¯ll see how they are useful in [pattern matching](#Pattern Matching).

## Pattern Matching

Pattern matching is a mechanism for checking a value against a pattern. A successful match can also deconstruct a value into its constituent parts. It is a more powerful version of the switch statement in Java and it can likewise be used in place of a series of if/else statements.


## Singleton Objects

Methods and values that aren¡¯t associated with individual instances of a class belong in singleton objects, denoted by using the keyword object instead of class.

## Regular Expression Patterns

Regular expressions are strings which can be used to find patterns (or lack thereof) in data. Any string can be converted to a regular expression using the .r method.

## EXTRACTOR OBJECTS

An extractor object is an object with an unapply method. Whereas the apply method is like a constructor which takes arguments and creates an object, the unapply takes an object and tries to give back the arguments. This is most often used in pattern matching and partial functions.

## FOR COMPREHENSIONS

Scala offers a lightweight notation for expressing sequence comprehensions. Comprehensions have the form for (enumerators) yield e, where enumerators refers to a semicolon-separated list of enumerators. An enumerator is either a generator which introduces new variables, or it is a filter. A comprehension evaluates the body e for each binding generated by the enumerators and returns a sequence of these values.

## Generic Classes

Generic classes are classes which take a type as a parameter. They are particularly useful for collection classes.

## UPPER TYPE BOUNDS

In Scala, type parameters and abstract types may be constrained by a type bound. Such type bounds limit the concrete values of the type variables and possibly reveal more information about the members of such types. An upper type bound **T <: A** declares that type variable **T** refers to a subtype of type **A**. Here is an example that demonstrates upper type bound for a type parameter of class Cage:


## LOWER TYPE BOUNDS

While upper type bounds limit a type to a subtype of another type, lower type bounds declare a type to be a supertype of another type. The term **B >: A** expresses that the type parameter B or the abstract type B refer to a supertype of type **A**. In most cases, **A** will be the type parameter of the class and B will be the type parameter of a method.

## INNER CLASSES

In Scala it is possible to let classes have other classes as members. As opposed to Java-like languages where such inner classes are members of the enclosing class, in Scala such inner classes are bound to the outer object. Suppose we want the compiler to prevent us, at compile time, from mixing up which nodes belong to what graph. Path-dependent types provide a solution.

## COMPOUND TYPES

Sometimes it is necessary to express that the type of an object is a subtype of several other types. In Scala this can be expressed with the help of compound types, which are intersections of object types.

## SELF-TYPE

Self-types are a way to declare that a trait must be mixed into another trait, even though it doesn¡¯t directly extend it. That makes the members of the dependency available without imports.

A self-type is a way to narrow the type of **this** or another identifier that aliases **this**. The syntax looks like normal function syntax but means something entirely different.

To use a self-type in a trait, write an identifier, the type of another trait to mix in, and a **=>** (e.g. ```someIdentifier: SomeOtherTrait =>```).

## IMPLICIT PARAMETERS

A method with implicit parameters can be applied to arguments just like a normal method. In this case the implicit label has no effect. However, if such a method misses arguments for its implicit parameters, such arguments will be automatically provided.

The actual arguments that are eligible to be passed to an implicit parameter fall into two categories:

+ First, eligible are all identifiers x that can be accessed at the point of the method call without a prefix and that denote an implicit definition or an implicit parameter.
+ Second, eligible are also all members of companion modules of the implicit parameter¡¯s type that are labeled implicit.

In the following example we define a method sum which computes the sum of a list of elements using the monoid¡¯s add and unit operations. Please note that implicit values can not be top-level, they have to be members of a template.

```java
/** This example uses a structure from abstract algebra to show how implicit parameters work. A semigroup is an algebraic structure on a set A with an (associative) operation, called add here, that combines a pair of A's and returns another A. */
abstract class SemiGroup[A] {
  def add(x: A, y: A): A
}
/** A monoid is a semigroup with a distinguished element of A, called unit, that when combined with any other element of A returns that other element again. */
abstract class Monoid[A] extends SemiGroup[A] {
  def unit: A
}
object ImplicitTest extends App {
  /** To show how implicit parameters work, we first define monoids for strings and integers. The implicit keyword indicates that the corresponding object can be used implicitly, within this scope, as a parameter of a function marked implicit. */
  implicit object StringMonoid extends Monoid[String] {
    def add(x: String, y: String): String = x concat y
    def unit: String = ""
  }
  implicit object IntMonoid extends Monoid[Int] {
    def add(x: Int, y: Int): Int = x + y
    def unit: Int = 0
  }
  /** This method takes a List[A] returns an A which represent the combined value of applying the monoid operation successively across the whole list. Making the parameter m implicit here means we only have to provide the xs parameter at the call site, since if we have a List[A] we know what type A actually is and therefore what type Monoid[A] is needed. We can then implicitly find whichever val or object in the current scope also has that type and use that without needing to specify it explicitly. */
  def sum[A](xs: List[A])(implicit m: Monoid[A]): A =
    if (xs.isEmpty) m.unit
    else m.add(xs.head, sum(xs.tail))

  /** Here we call sum twice, with only one parameter each time. Since the second parameter of sum, m, is implicit its value is looked up in the current scope, based on the type of monoid required in each case, meaning both expressions can be fully evaluated. */
  println(sum(List(1, 2, 3)))          // uses IntMonoid implicitly
  println(sum(List("a", "b", "c")))    // uses StringMonoid implicitly
}
```

## IMPLICIT CONVERSIONS

An implicit conversion from type **S** to type **T** is defined by an implicit value which has function type **S => T**, or by an implicit method convertible to a value of that type.

Implicit conversions are applied in two situations:

+ If an expression e is of type S, and S does not conform to the expression¡¯s expected type T.
+ In a selection e.m with e of type S, if the selector m does not denote a member of S.

In the first case, a conversion c is searched for which is applicable to e and whose result type conforms to T. In the second case, a conversion c is searched for which is applicable to e and whose result contains a member named m.


## POLYMORPHIC METHODS

Methods in Scala can be parameterized by type as well as value. The syntax is similar to that of generic classes. Type parameters are declared within a pair of brackets while value parameters are enclosed in a pair of parentheses.


